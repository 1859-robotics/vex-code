#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, ,               sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           L_CORE_LIFT,   tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           L_MANIPULATOR, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           FLIP_LIFT,     tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port4,           LF_DRIVE,      tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           RB_DRIVE,      tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RF_DRIVE,      tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port7,           LB_DRIVE,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           LIFT_CLAW,     tmotorVex393_MC29, openLoop, encoderPort, dgtl11)
#pragma config(Motor,  port9,           R_MANIPULATOR, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port10,          R_CORE_LIFT,   tmotorVex393_HBridge, openLoop)
#pragma config(Sensor, in1,    GYRO_PORT,      sensorGyro)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")
#pragma DebuggerWindows("debugStream")
#pragma DebuggerWindows("VexLCD")
#pragma DebuggerWindows("vexCompetitionControl")
#pragma DebuggerWindows("taskStatus")



#pragma platform(VEX2)
#pragma competitionControl(Competition)

// libs
#include "Vex_Competition_Includes.c"
#include "./lib/SmartMotorLib.c"


#include "./prototype/util.c"

// external file includes
#include "./prototype/joystick_defines.c"
#include "./prototype/drive.c"
#include "./prototype/lift.c"
#include "./prototype/manipulator.c"


#include "./prototype/auton.c"
// #include "./prototype/lcd.c"
#include "./prototype/operatorControl.c"


 int count = 0;
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
  while(nLCDButtons == 0){}
  wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
  while(nLCDButtons != 0){}
  wait1Msec(5);
}
//----------------------------------------------------------------



void pre_auton() {
  // smart motor application
  // TODO: cut down smartmotorlib bulk. disallow 292, etc.
  SmartMotorsInit();

  driveInit();
  liftInit();
  maniplulatorInit();

   //Loop while center button is not pressed
   while(nLCDButtons != centerButton)
   {
     //Switch case that allows the user to choose from 4 different options
     switch(count){
     case 0:
       //Display first choice
       displayLCDCenteredString(0, "RIGHT 22");
       displayLCDCenteredString(1, "<     Enter    >");
       waitForPress();
       //Increment or decrement "count" based on button press
       if(nLCDButtons == leftButton)
       {
         waitForRelease();
         count = 3;
       }
       else if(nLCDButtons == rightButton)
       {
         waitForRelease();
         count++;
       }
       break;
     case 1:
       //Display second choice
       displayLCDCenteredString(0, "RIGHT 7");
       displayLCDCenteredString(1, "<     Enter    >");
       waitForPress();
       //Increment or decrement "count" based on button press
       if(nLCDButtons == leftButton)
       {
         waitForRelease();
         count--;
       }
       else if(nLCDButtons == rightButton)
       {
         waitForRelease();
         count++;
       }
       break;
     case 2:
       //Display third choice
       displayLCDCenteredString(0, "LEFT 22");
       displayLCDCenteredString(1, "<     Enter    >");
       waitForPress();
       //Increment or decrement "count" based on button press
       if(nLCDButtons == leftButton)
       {
         waitForRelease();
         count--;
       }
       else if(nLCDButtons == rightButton)
       {
         waitForRelease();
         count++;
       }
       break;
       case 3:
         //Display third choice
         displayLCDCenteredString(0, "LEFT 7");
         displayLCDCenteredString(1, "<     Enter    >");
         waitForPress();
         //Increment or decrement "count" based on button press
         if(nLCDButtons == leftButton)
         {
           waitForRelease();
           count--;
         }
         else if(nLCDButtons == rightButton)
         {
           waitForRelease();
           count++;
         }
         break;
     case 4:
       //Display fourth choice
       displayLCDCenteredString(0, "SKILLS");
       displayLCDCenteredString(1, "<     Enter    >");
       waitForPress();
       //Increment or decrement "count" based on button press
       if(nLCDButtons == leftButton)
       {
         waitForRelease();
         count--;
       }
       else if(nLCDButtons == rightButton)
       {
         waitForRelease();
         count = 0;
       }
       break;
     default:
       count = 0;
       break;
     }

 }


  clearLCDLine(0);
  clearLCDLine(1);

  displayLCDCenteredString(0, "position bot");
  displayLCDCenteredString(1, "still");

  waitForPress();
  SensorType[GYRO_PORT] = sensorNone;
  wait1Msec(1000);

  SensorType[GYRO_PORT] = sensorGyro;
  wait1Msec(2000);


 bStopTasksBetweenModes = true;
 }

  // selectAuton();


task autonomous() {
	SmartMotorRun();
  //Switch Case that actually runs the user choice
    switch(count){
    case 0:
      //If count = 0, run the code correspoinding with choice 1
      displayLCDCenteredString(0, "RIGHT 22");
      displayLCDCenteredString(1, "is running!");

      auton22ptRight();


    break;
    case 1:
      auton7ptRight()

      //If count = 1, run the code correspoinding with choice 2
      displayLCDCenteredString(0, "RIGHT 7");
      displayLCDCenteredString(1, "is running!");


      break;
    case 2:


      displayLCDCenteredString(0, "LEFT 22");
      displayLCDCenteredString(1, "is running!");


      auton22ptLeft();



      break;
    case 3:

    auton7ptLeft();

      displayLCDCenteredString(0, "LEFT 7");
      displayLCDCenteredString(1, "is running!");




      break;
      case 4:


        displayLCDCenteredString(0, "skills");
        displayLCDCenteredString(1, "is running!");


        skills();



        break;
      default:
      displayLCDCenteredString(0, "No valid choice");
      displayLCDCenteredString(1, "was made!");
      break;
    }
  }


  // runAuton();






task usercontrol() {
	SmartMotorRun();
  startTask(taskOPCdrive);
  startTask(taskOPCmanipulate);
  startTask(taskOPClift);



  while (true) {


    wait1Msec(20);
  }
}
